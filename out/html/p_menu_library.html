<HTML>
<HEAD>
<TITLE> The menu_* library </TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY leftmargin="0" rightmargin="0"  topmargin="0" marginwidth="0" marginheight="0">
<TABLE WIDTH="100%" HEIGHT="100%" BORDER="0" cellpadding="0" cellspacing="0" >
	<TR HEIGHT=75 bgcolor=#125492> 
		<TD>
			<image src="logo.gif" >
			<font color="#FFFFFF" size="5" face="ArialBlack">
			version 0.82
			</FONT>
		</TD> 
	</TR>
	<TR HEIGHT=1 bgcolor=#808080><TD></TD></TR>
	<TR HEIGHT=1 bgcolor=#D4D0C8><TD></TD></TR>
	<TR HEIGHT=5 bgcolor=#FFFFFF><TD></TD></TR>
	<TR BGCOLOR=#FFFFFF ALIGN="left"> <TD VALIGN="top">
		<TABLE WIDTH=100% cellpadding="0" cellspacing="0">
			<TR>
				<TD WIDTH=30  VALIGN=top >
					<TABLE WIDTH=30 cellpadding="0" cellspacing="0">
						<TR HEIGHT=26 bgcolor=#FFFFFF><TD></TD></TR>
						<TR HEIGHT=1 bgcolor=#808080><TD></TD></TR>
						<TR HEIGHT=1 bgcolor=#D4D0C8><TD></TD></TR>
						<TR><TD></TD></TR>
					</TABLE>
				</TD>
				<TD>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="p_menu_library">The menu_* library</a></h1>Sending data to UO is commonly done in 2 ways:<ul>
<li>by tyiping something and then pressing return</li><li>by interacting with Graphical User Interface (GUI) objects, in simple words: menus</li></ul>
<p>
Sending data by typing it is not a user friendly way of interacting with the game,user usually prefer graphical things, wich are more intuitive and beter looking.<br>
 Here you'll learn how to create and manage menus.<br>
 NOX has script_API_gui API library that contains APIs to draw gui objects on the client, allowing you to draw whatever you want on the player's screen, the only limitation is that all you want to draw must be in .mul files.<br>
 If you already tested gui_* functions you certainly have noticed how difficult is to draw a complex menu because you have to specify the (x,y) position of every item and every function call takes a lot of parameters: the resulting code is usaually a terrible mess!<br>
 gui_* function give you control on every little detail of you gump but in most cases this precise control is not needed, mainly you will want to draw buttons, text, checkboxes in a regular pattern, as if you were drawing them on a grid, and you will find out that usually your gumps share a large part of code, so actually you have to script always the same tedious things when you do a new gump.<br>
 <br>
 To help scripters writing gumps I developed a <a class="el" href="group__script__API__gui__menu.html">menu library</a> wich takes care of doing all the repetitive tasks leaving you only the duty of coding gump parts that are really important.<br>
 The library is simply a list of functions that use standard gui_* APIs to draw predefined objects in your menu, the difference with the gui_* APIs is that the menu_* functions require much less coding to do the same things than gui_* would.<br>
 Before going into the library description you'll have to learn about ...<h2><a class="anchor" name="thecursor">
The cursor</a></h2>
One of the most annoying things in writing standard gui_* gumps is the (x,y) positioning of objects, the script_API_gui_cursor comes to help in this task by subdividing the screen in a grid and by giving you control over a virtual "cursor" that runs trough the grid.<br>
 I know that explanation wasn't clear, I'll eplain again in other words.<br>
 Take any text editing program, the blinking vertical segment in the text area is the cursor.<br>
 If you press the arrow buttons on your keyboard the cursor moves around the screen step by step, the steps correspond to a letter width and to a line height, you don't have to worry about the exact position (in pixels), you have limited a text editing area where the cursor is allowed to move and you move the cursor by steps.<br>
 In addition the cursor can be moved to the end of the line, to the beginning, can go ahead by some steps allby pressing buttons on the keyboard (eg: the tab button).<br>
 The virtual cursor in the script_API_gui_cursor library does exactly the same things, has a predefined working area and can be moved step by step without worring about the exact position, functions are provided to simulate the keyboard keys so you can drive the virtual cursor using a virtual keyboard.<br>
 Obviously you won't see any cursor in the screen, that's because I call it "virtual".<br>
<h2><a class="anchor" name="menulibrary">
The menu_* library</a></h2>
The <a class="el" href="group__script__API__gui__menu.html">menu library</a> uses the virtual cursor to draw the objects, all objects are drawn at the current cursor's position, that's why menu_* functions never require (x,y) parameters: they use the current cursor's x and y as position for the object.<br>
 This is a great simplification not only because you saved 2 parameters in every function call, but mainly because now you can draw the menu objects without having to calculate the exact (x,y) position, you simply have to move the cursor to the position you want and then draw the object.<br>
 This is not the only feature of the library.<br>
 When you build a menu your buttons usually have all the same apearance, also all the checkboxes do, and so do the page buttons, it would be nice if you wouldn't have to specify the object appearance every time, and problably all your menus share the same set of gumps to draw buttons and aother objects, so maybe you could store somwhere all the gumps and then never specify them again.<br>
 The menu_* library does eactly these things, it has some predefined gumps that are used to draw objects so the library functions don't need parameters to specify the objects appearance, it's another 2 params saved for each function call with respect to the gui_* APIs<br>
 Now consider adding a button, usually you will add some text near it to explain wht that button is for, so you have to draw the button and then draw the text next to it (2 lines of code), wouldn't it be nice if there was and object that is formed by a button AND a text? call this a "labeled button": a button with some text next to it, seen as an only object.<br>
 Useless to say ... the menu_* library allows you to add objects of that kind with only 1 function call! And that function call doesn't take position and gump information! that's a lot of coding saved!<br>
 Actually the library has some more cool feature that sometimes makes you create a full menu with a single function call, but I'm not going to detail them here (you can find all the documentation on these functions in the <a class="el" href="group__script__API__gui__menu.html">menu library</a> reference) I'm going to show you how to use them to build a menu.<br>
<h2><a class="anchor" name="internalorganization">
Internal library organization</a></h2>
The main library concept is the assumption that you will work on a single menu at a time, wich is usually true (I never worked on 2 menus at the same time in a script).<br>
 If you are working on a single menu there is no need to specify the menu on every function call, once you created the menu it's serial is stored as the "current menu" and all functions will refer to that manu.<br>
 When you create a menu with one of the menu creation functions <pre class="fragment"><div>        stock <a class="code" href="group__script__API__gui__menu.html#ga4">createMenu</a>(startx,starty,callback[])
        stock <a class="code" href="group__script__API__gui__menu.html#ga7">createFramedMenu</a>(startx,starty,rows1,rows2,cols,callback[])
        stock <a class="code" href="group__script__API__gui__menu.html#ga8">createStdMenu</a>(startx,starty,rows,cols,title[],callback[])
        <a class="code" href="group__script__API__gui__menu.html#ga9">createPopupMenu</a>(title[],message[])
        <a class="code" href="group__script__API__gui__menu.html#ga11">createListMenu</a>(startx,starty,rows,cols,nitems,title[],callback[],menuCallback[])
</div></pre>a new gui object is created and it's serial stored in <pre class="fragment"><div>        <span class="keyword">static</span> currentMenu;
</div></pre>the current menu serial is returned by the functions too, so you can always have control on what you created.<br>
 You can delete a menu with <pre class="fragment"><div>        <a class="code" href="group__script__API__gui__menu.html#ga5">menu_delete</a>();
</div></pre>note that you do not have to pass the menu serial.<br>
 Once you created the menu you can show it itwith one of the mwnu showing functions <pre class="fragment"><div>        stock <a class="code" href="group__script__API__gui__menu.html#ga36">menu_show</a>(chr)
        stock <a class="code" href="group__script__API__gui__menu.html#ga37">menu_broadcast</a>()
</div></pre><br>
 Depending on which function you used to create the menu,if you show a memnu right after creating it you will get different results <pre class="fragment"><div>        <a class="code" href="group__script__API__gui__menu.html#ga4">createMenu</a>(0,0,<span class="stringliteral">"mycallback"</span>);
        <a class="code" href="group__script__API__gui__menu.html#ga36">menu_show</a>(chr);
</div></pre>won't do anything, while<p>
<pre class="fragment"><div>        <a class="code" href="group__script__API__gui__menu.html#ga8">createStdMenu</a>(0,0,10,20,<span class="stringliteral">"Hello"</span>,<span class="stringliteral">"mycallback"</span>);
        <a class="code" href="group__script__API__gui__menu.html#ga36">menu_show</a>(chr);
</div></pre>will result in a simple blank menu titled "Hello", let's explain why ...<h3><a class="anchor" name="thestandardframe">
The standard frame</a></h3>
All menus built using menu_* functions will look similar, this is because all menu creation functions share a common menu appearance: the "standard frame".<br>
 The standard frame is what you see on screen if you try the above piece of code: a menu with a red title and a red "Nox wizard" text at the bottom, divided in 2 sections, one of wich is occupied by the title, this is the standard apeearance of all menus in in this library (we'll see how to change it), so when you create a menu you don't have to write code for the basic menu appearance, it's all automatic.<br>
 The standard frame is more than a visual thing, when the standard frame is drawn with <pre class="fragment"><div>        <span class="keyword">static</span> <a class="code" href="group__script__API__gui__menu.html#ga6">menu_drawStandardFrame</a>(rows1,rows2,cols)
</div></pre>the cursor is positioned at the top left corner of the text area and it's limits are set to the text area too, so after creating a menu if you add an item to the menu it will appear in the top left corner of the text area.<br>
 Obviously the library grants some flessibility, that's why there are 5 menu creation functions, each of them creates a more complex menu so <a class="el" href="group__script__API__gui__menu.html#ga4">createMenu()</a> creates an empty menu, <a class="el" href="group__script__API__gui__menu.html#ga8">createStdMenu()</a> creates a full menu, other functions create all that's between this two extremes, play a bit with them to understand what I mean.<br>
<h3><a class="anchor" name="addingitems">
Adding items</a></h3>
You can add items to the menu with the menu_add* functions, I'm not going to detail all of them as their behaviour can be easily understood by their name, the only thing I want to say is that all items are placed at current cursor's position and that the cursor is NOT moved after the item positioning.<h3><a class="anchor" name="properties">
Properties</a></h3>
You can change the overall menu appearance by setting the menu properties, this is done with <pre class="fragment"><div>        stock <a class="code" href="group__script__API__gui__menu.html#ga15">menu_setProperty</a>(prop,value)
</div></pre><p>
menu properties define the menu appearance,refer to the  reference to know wich they are and what they are for.<br>
 You should set the properties before starting menu creation so they will set the menu appearance.<br>
 You can also change some properties temporarly, for example if you want a button different fromthe standard ones, this is done by passing some additional parameters to the functions, specifing the new property value.<br>
 The new value will apply only for the item you are placing.<br>
 <br>
 <br>
 I'm not going to report examples because you can find the best examples in the standard scripts, you can check <a class="el" href="regioncp_8sma.html">regioncp.sma</a> <a class="el" href="skillsmenu_8sma.html">skillsmenu.sma</a> <a class="el" href="addmenu_8sma.html">addmenu.sma</a> <a class="el" href="popup_8sma.html">popup.sma</a> and other scripts.<br>
 				</TD>
				<TD WIDTH=30  VALIGN=top >
					<TABLE WIDTH=30 cellpadding="0" cellspacing="0">
						<TR HEIGHT=26 bgcolor=#FFFFFF><TD></TD></TR>
						<TR HEIGHT=1 bgcolor=#808080><TD></TD></TR>
						<TR HEIGHT=1 bgcolor=#D4D0C8><TD></TD></TR>
						<TR><TD></TD></TR>
					</TABLE>
				</TD>
			</TR>
		</TABLE>
		</TD> 
	</TR>
	<TR HEIGHT=5 bgcolor=#FFFFFF><TD></TD></TR>
	<TR HEIGHT=1 bgcolor=#D4D0C8><TD></TD></TR>
	<TR HEIGHT=1 bgcolor=#808080><TD></TD></TR>
	<TR HEIGHT=75 bgcolor=#125492 ALIGN=right> <TD>
		<font color="#FFFFFF" size="4" face="ArialBlack">
			Documentation generated 29 May 2004 &nbsp&nbsp
		</FONT>
	</TD> 
	</TR>
</TABLE>
</BODY>
</HTML>
