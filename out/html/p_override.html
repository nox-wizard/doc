<HTML>
<HEAD>
<TITLE> Overrides,events and callbacks </TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY leftmargin="0" rightmargin="0"  topmargin="0" marginwidth="0" marginheight="0">
<TABLE WIDTH="100%" HEIGHT="100%" BORDER="0" cellpadding="0" cellspacing="0" >
	<TR HEIGHT=75 bgcolor=#125492> 
		<TD>
			<image src="logo.gif" >
			<font color="#FFFFFF" size="5" face="ArialBlack">
			version 0.82
			</FONT>
		</TD> 
	</TR>
	<TR HEIGHT=1 bgcolor=#808080><TD></TD></TR>
	<TR HEIGHT=1 bgcolor=#D4D0C8><TD></TD></TR>
	<TR HEIGHT=5 bgcolor=#FFFFFF><TD></TD></TR>
	<TR BGCOLOR=#FFFFFF ALIGN="left"> <TD VALIGN="top">
		<TABLE WIDTH=100% cellpadding="0" cellspacing="0">
			<TR>
				<TD WIDTH=30  VALIGN=top >
					<TABLE WIDTH=30 cellpadding="0" cellspacing="0">
						<TR HEIGHT=26 bgcolor=#FFFFFF><TD></TD></TR>
						<TR HEIGHT=1 bgcolor=#808080><TD></TD></TR>
						<TR HEIGHT=1 bgcolor=#D4D0C8><TD></TD></TR>
						<TR><TD></TD></TR>
					</TABLE>
				</TD>
				<TD>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="p_override">Overrides,events and callbacks</a></h1>Overrides, callbacks and event handlers are the way we can run our Small scripts, so this is the core of NOX scripting<p>
<h4>CALLBACKS</h4>
<p>
A callback is a public small function that is called by the emulator. You can declare/implement the function where you want, but it must be public, or the emulator won't see it. Since the function is called by the source code, you don't have control on the parameters passed to it, so the prototype of a callback is determined and depends on the use of the callback. Every NOX feature that requires callbacks will provide the prototype to be used.<p>
<h4>OVERRIDES</h4>
<p>
overrides are declared in override.scp and are used to execute custom code wich will extend or bypass the standard source code. If you open override.scp you will see there are some sections, identified by [name]. The only sections you have to worry about are:<p>
<ul>
<li>
[skilltargets] </li>
<li>
[skills] </li>
<li>
[special] </li>
<li>
[speech] </li>
</ul>
other sections are either unused or there is a bettere way to call your script (with event handlers for example)<p>
In these sections you will put some code to tell the emulator what script must be called and when.<p>
<b>modes</b><br>
 Ther are 4 "modes" to call a script: <ul>
</ul>
: you script is called before the standard source code is executed AFTER: the script is called after the source code BYPASS: the script is called instead of the source code FRAME: the scipt is called both before and after the source code <p>
<b>Callback prototypes</b><br>
 Your callback will be passed the socket of the character who triggered the override, so the function protoype must be:<p>
<div class="fragment"><pre><span class="keyword">public</span> myfunction(<span class="keyword">const</span> socket)
</pre></div><p>
<h4>sections usage and syntax</h4>
<p>
<br>
 Now let's analyze each section to see how you can use it<p>
<b>section [skilltargets]</b><br>
<p>
in this section you can specify a public function that will be called when the char is targeting something after a skill use (i.e.: anatomy, armslore ecc..) the syntax is:  code&lt;function name&gt;,<p>
is the number associated with skill, you will find it in small-scripts/skills/constant.sma<p>
is the name of the public function you want to be called  is one of the modes explained previously<p>
example: <div class="fragment"><pre>4=myArmsloreFunction,BYPASS  <span class="comment">//this will bypass the standard armslore code with your code </span>
</pre></div><p>
<b>section [skills]</b><br>
 here your specified function will be called when the charactere uses a skill the syntax is the same as for [skilltargets]<p>
<b>section [special]</b><br>
 here you can use some special overrides with the following syntax: <div class="fragment"><pre>&lt;overridetype&gt;=&lt;function&gt;,&lt;mode&gt; 
</pre></div><p>
is one of the following: OnStart: fired on server startup, available only as AFTER OnLoop: fired on each server cycle, available only as AFTER StartChar: fired on character startup, available only as AFTER OnExit: fired on clean server shutdown, available only as AFTER<p>
<b>section [speech]</b><br>
 with this override you can execute a script when a character spells a word, the syntax is: =,BEFORE<p>
if in the char speech there is the , your function will be called.<p>
<h4>EVENT HANDLERS</h4>
<p>
Event handler allow you to to extend or bypass the source code in a number of locations, they are a bit more complex to use than overrides, but they are very much more powerful! The concept is that callback will be called when an event happens, an event can be a double click, a character passing on an object, a charcter being attaccked by another and so on, for each of these events you can link to a character or an item a callback with your script, so the main difference with overrides is that event handlers are "personal", they are related to a single object (char or item).<p>
how to link an event handler to an object there are several ways to link an event to an object, wich way is the best one depends on the situation, you can link the event in:<ul>
<li>XSS definitions</li><li>SECTION NEWBIE</li><li>small code</li></ul>
<p>
<b>XSS definition linking</b><br>
 in the XSS definition of an item or character put a line with the following syntax:  <p>
is one of the available event handlers (like , ) see the file small-scripts/events/constants.sma for the available events  is the name of the callback<p>
example: <div class="fragment"><pre>SECTION ITEM $item_anvil_1 
{ 
    ID 0FB0 
    @ONDBLCLICK __blacksmith  <span class="comment">//this will call function __blacksmith when the anvil is double clicked </span>
} 
</pre></div><p>
linking an event handler this way will cause EVERY object created with that script to have the event linked, so in this example every anvil created with that script will call __blacksmith when double clicked<p>
<b>SECTION NEWBIE linking</b><br>
 in section newbie you can link an avent handler to ALL the new playng characters, this event will be linked to all chars (not NPCs) when they are created, simply add a line similar to the "XSS definition linking" syntax in SECTION NEWBIE in newbie.xss<p>
<b>Small code linking</b><br>
 You can link an event handler to an object at runtime using the following functions in your small code:<br>
<ul>
<li>chr_setEventHandler(const chr, const event, const evtype, const format[],...)</li><li>itm_setEventHandler(const itm, const event, const evtype, const format[], ...)</li></ul>
<p>
chr, itm: is the serial of char or item the event will be linked to<br>
 event: is the event to link (,  ecc..)<br>
 evtype: is type of the event, can be EVENTTYPE_DYNAMIC or EVENTTYPE_STATIC, the first type of events won't be save in worldsaves, the second will be saved.<br>
 format: is the name of the callback function that will be called when the event is triggered, supports C-like syntax for the format string.<br>
<p>
when you link an event this way the event is linked ONLY to the object (item or char) you passed to the function.<p>
You can get the callback name of an event handler linked to an object with:<br>
<ul>
<li>chr_getEventHandler(const chr, const event, handler[])</li><li>itm_getEventHandler(const itm,const event, handler[])</li></ul>
<p>
chr, itm: is the serial of char or item the event is linked to<br>
 event: the event <br>
 handler: a string in wich will be stored the name of the callback<br>
<p>
You can delete an event from an object with:<br>
<ul>
<li><a class="el" href="group__script__API__character__events.html#ga2">chr_delEventHandler(const chr, const event)</a></li><li><a class="el" href="group__script__API__item.html#ga31">itm_delEventHandler(const itm, const event)</a></li></ul>
<p>
<b>callback proptotypes</b><br>
 the callback prototype is different for each event, you will finde most of the event descriptions and callback prototypes in the "small scripting guide" in the NOX site's help page. Usually you can omit some parameters from the callback definition if you know you won't use them, but you can omit only the last parameters. I think omitting parameters is not a good practice because it can easily lead to errors, but if necessary you know you can.<p>
<b>bypassing</b><br>
 With function <a class="el" href="misc_8api.html#a0">bypass()</a> you can tell the emulator not to execute his source code, this way your callback's code will take place of the source code. Bypassing source code is a very powerful feature, but it's dangerous too, if you don't know the server standard behaviour you might cause errors or other problems. Usually there are no problems in bypassing, as event handlers are designed to allow bypassing and all vital chacks are usually done before your callback is called, but if you can, always take a look at the source code the first time you bypass an event, of course not all can easily read C++ code so no problem if you can't, but many times is very useful to understand what you can do. 				</TD>
				<TD WIDTH=30  VALIGN=top >
					<TABLE WIDTH=30 cellpadding="0" cellspacing="0">
						<TR HEIGHT=26 bgcolor=#FFFFFF><TD></TD></TR>
						<TR HEIGHT=1 bgcolor=#808080><TD></TD></TR>
						<TR HEIGHT=1 bgcolor=#D4D0C8><TD></TD></TR>
						<TR><TD></TD></TR>
					</TABLE>
				</TD>
			</TR>
		</TABLE>
		</TD> 
	</TR>
	<TR HEIGHT=5 bgcolor=#FFFFFF><TD></TD></TR>
	<TR HEIGHT=1 bgcolor=#D4D0C8><TD></TD></TR>
	<TR HEIGHT=1 bgcolor=#808080><TD></TD></TR>
	<TR HEIGHT=75 bgcolor=#125492 ALIGN=right> <TD>
		<font color="#FFFFFF" size="4" face="ArialBlack">
			Documentation generated 20 Feb 2004 &nbsp&nbsp
		</FONT>
	</TD> 
	</TR>
</TABLE>
</BODY>
</HTML>
