

/*! \page p_small Small
* \section small The Small language
* Most of the NOX wizard's high flexibility comes from its powerful scripting language: Small.
The Small language is not a NOX specific language, it's a scripting language developed to easily
extend applications, without needing particular programming skills. You can learn all about Small
downloading the reference manual from the official site: <A HREF="http://www.compuphase.com/small.htm"> http://www.compuphase.com/small.htm </A>
<br>
The Small language is designed to be simple and fast, and it really is!
An experienced C programmer will master Small in an afternoon due to his similarity with C,
If you are a beginner C programmer, still scared by pointers and references, fear not, Small
doesn't have all such difficult things.
If you come from other scripting languages, you will get familiar with the sintax in a few days of practice.
If you are not a programmer and you see a programming language for the first time, you will find here 
a lot of tutorials that will help you.

\subsection API_reference API reference
* <UL>
* <LI> \ref script_API
* </UL>
\subsection NOX_small NOX-Small scripting guide
* <UL>
* <LI> \ref p_override
* <LI> \ref p_targetting
* </UL>
*/

/*
\subsection tutorials Tutorials and examples
* By type with tutorial:
* <UL>
* <LI> \ref p_set
* <LI> \ref p_dinamic_var
* </UL>
*
*/

/*! \page p_dinamic_var Variabili Dinamiche
* \section dinamin_var Variabili Dinamiche
*  
*  Come avere infinite variaibli a disposizione
*  
*  
*  
*/


//============================================================================================
//=======================  OVERRIDES, CALLBACKS AND EVENT HANDLERS  ==========================
//============================================================================================

/*! \page p_override Overrides,events and callbacks
Overrides, callbacks and event handlers are the way we can run our Small scripts, so this is
the core of NOX scripting

<H4>CALLBACKS</H4> 
A callback is a public small function that is called by the emulator.
You can declare/implement the function where you want, but it must be public, or the emulator
won't see it. 
Since the function is called by the source code, you don't have control on the parameters passed to it, so the prototype of a callback is determined and depends on the use of the callback. 
Every NOX feature that requires callbacks will provide the prototype to be used. 

<H4>OVERRIDES</H4> 
overrides are declared in override.scp and are used to execute custom code wich will extend or bypass the standard source code. 
If you open override.scp you will see there are some sections, identified by [name]. 
The only sections you have to worry about are: 

<UL>
<LI>[skilltargets] 
<LI>[skills] 
<LI>[special] 
<LI>[speech] 
</UL>
other sections are either unused or there is a bettere way to call your script (with event handlers for example) 

In these sections you will put some code to tell the emulator what script must be called and when. 

<B>modes</B><br> 
Ther are 4 "modes" to call a script: 
<UL>BEFORE: you script is called before the standard source code is executed 
<LI>AFTER: the script is called after the source code 
<LI>BYPASS: the script is called instead of the source code 
<LI>FRAME: the scipt is called both before and after the source code 
</UL>

<B>Callback prototypes</B><br> 
Your callback will be passed the socket of the character who triggered the override, so the function protoype must be: 

\code
public myfunction(const socket)
\endcode

<H4>sections usage and syntax</H4><br> 
Now let's analyze each section to see how you can use it 

<B>section [skilltargets]</B><br> 

in this section you can specify a public function that will be called when the char is targeting something after a skill use (i.e.: anatomy, armslore ecc..) 
the syntax is: 
<skillnumber> 
code<function name>,<mode> 

<skillnumber> is the number associated with skill, you will find it in small-scripts/skills/constant.sma 

<function name> is the name of the public function you want to be called 
<mode> is one of the modes explained previously 

example: 
\code
4=myArmsloreFunction,BYPASS  //this will bypass the standard armslore code with your code 
\endcode 


<B>section [skills]</B><br> 
here your specified function will be called when the charactere uses a skill 
the syntax is the same as for [skilltargets] 

<B>section [special]</B><br> 
here you can use some special overrides with the following syntax:
\code 
<overridetype>=<function>,<mode> 
\endcode

<overridetype> is one of the following: 
OnStart: fired on server startup, available only as AFTER 
OnLoop: fired on each server cycle, available only as AFTER 
StartChar: fired on character startup, available only as AFTER 
OnExit: fired on clean server shutdown, available only as AFTER 

<B>section [speech]</B><br> 
with this override you can execute a script when a character spells a word, the syntax is: 
<word>=<function>,BEFORE 

if in the char speech there is the <word>, your function will be called. 

<H4>EVENT HANDLERS</H4> 
Event handler allow you to to extend or bypass the source code in a number of locations, they are a bit more complex to use than overrides, but they are very much more powerful! 
The concept is that callback will be called when an event happens, an event can be a double click, a character passing on an object, a charcter being attaccked by another and so on, for each of these events you can link to a character or an item a callback with your script, so the main difference with overrides is that event handlers are "personal", they are related to a single object (char or item). 

how to link an event handler to an object 
there are several ways to link an event to an object, wich way is the best one depends on the situation, you can link the event in: 
   - XSS definitions 
   - SECTION NEWBIE 
   - small code 


<B>XSS definition linking</B><br> 
in the XSS definition of an item or character put a line with the following syntax: 
<event> <callback> 

<event> is one of the available event handlers (like @ONDBLCLICK, @ONDEATH) see the file small-scripts/events/constants.sma for the available events 
<callback> is the name of the callback 

example: 
\code
SECTION ITEM $item_anvil_1 
{ 
    ID 0FB0 
    @ONDBLCLICK __blacksmith  //this will call function __blacksmith when the anvil is double clicked 
} 
\endcode 


linking an event handler this way will cause EVERY object created with that script to have the event linked, so in this example every anvil created with that script will call __blacksmith when double clicked 

<B>SECTION NEWBIE linking</B><br> 
in section newbie you can link an avent handler to ALL the new playng characters, this event will be linked to all chars (not NPCs) when they are created, simply add a line similar to the "XSS definition linking" syntax in SECTION NEWBIE in newbie.xss 

<B>Small code linking</B><br> 
You can link an event handler to an object at runtime using the following functions in your small code:<br> 
   - chr_setEventHandler(const chr, const event, const evtype, const format[],...) 
   - itm_setEventHandler(const itm, const event, const evtype, const format[], ...) 

chr, itm: is the serial of char or item the event will be linked to<br> 
event: is the event to link (@ONWALKOVER, @ONKILL ecc..)<br> 
evtype: is type of the event, can be EVENTTYPE_DYNAMIC or EVENTTYPE_STATIC, the first type of events won't be save in worldsaves, the second will be saved.<br> 
format: is the name of the callback function that will be called when the event is triggered, supports C-like syntax for the format string.<br> 

when you link an event this way the event is linked ONLY to the object (item or char) you passed to the function. 

You can get the callback name of an event handler linked to an object with:<br> 
   - chr_getEventHandler(const chr, const event, handler[]) 
   - itm_getEventHandler(const itm,const event, handler[]) 

chr, itm: is the serial of char or item the event is linked to<br> 
event: the event <br>
handler: a string in wich will be stored the name of the callback<br> 

You can delete an event from an object with:<br> 
   - chr_delEventHandler(const chr, const event) 
   - itm_delEventHandler(const itm, const event)

<B>callback proptotypes</B><br> 
the callback prototype is different for each event, you will finde most of the event descriptions and callback prototypes in the "small scripting guide" in the NOX site's help page. 
Usually you can omit some parameters from the callback definition if you know you won't use them, but you can omit only the last parameters. 
I think omitting parameters is not a good practice because it can easily lead to errors, but if necessary you know you can. 

<B>bypassing</B><br> 
With function bypass() you can tell the emulator not to execute his source code, this way your callback's code will take place of the source code. 
Bypassing source code is a very powerful feature, but it's dangerous too, if you don't know the server standard behaviour you might cause errors or other problems. 
Usually there are no problems in bypassing, as event handlers are designed to allow bypassing and all vital chacks are usually done before your callback is called, but if you can, always take a look at the source code the first time you bypass an event, of course not all can easily read C++ code so no problem if you can't, but many times is very useful to understand what you can do. 
*/

//=================================================================================================
//==============================    TARGETTING    =================================================
//=================================================================================================

/*! 
* \page p_targetting Targetting

As an UO player you surely know what does "targetting" mean: you are targetting when you left click an item
or character with the target pointer<br>
Targetting is necessary to interact with the UO world, so in your scripts you surely will have to manage targetting<br>
Here we'll discuss the question from NOX wizard scripter's point of view.<br>

* \subsection whatsatarget What's a target?
Many times we refer to a target thinking it to be the object we selected with the targetting action.<br>
For example when we attack someone we click on him and we say he is our target.<br>
When you are scripting the question is a bit different<br>
A target is an object wich allows us to manage the targetting action<br>
You can create a target with:

\code
new target = target_create(chr, _, _, _, "mycallback");
\endcode

click the link to know more on the target_create function parameters.<br>
From the client point of view, this line of code causes the target pointer to appear, so this line will make the player
able to click on something. 

\subsection howworks How do targets work
When you create/activate a target the following things happen: <br>
<UL>
<LI>the target is created for the character you specified
<LI>the target notification is sent to the client
<LI>the player clicks something
<LI>the server receives a notification that something has been clicked
<LI>the Small callback you specified is called to perform some actions
</UL>

The only things you have to worry about are the first and last points, all the thing between are managed
by the source code.<br>
But analyzing the sequence you should notice a very important thing: the whole process is not purely sequential, 
that is, the operations are not performet one just after the other. Why? Because of the 3rd point!
To go on with target management the server has to wait for the player to click something, and you will never know
when this will happen!<br>
This will have heavy consequences on how you will structure your code.

\subsection callback Callback proptotype
Your callback function must have the following proptotype:
public callback( const target, const chr, const obj, const x, const y, const z, const model, const param1 )
<b>target:</b> is the target wich called the function<br>
<b>chr:</b> is the character who clicked on something<br>
<b>object:</b> the item or character targetted, INVALID if no object targetted<br>
<b>x,y,z:</b> if the player targetted the ground or other map locations, these are the coordinates, else x,y,z are INVALID<br>
<b>model:</b> is valid when targetted an item or a static tile, not when a land tile is targetted<br>
<b>param1:</b> is the first param passed<br>
<b>param2:</b> passed to target_create can be getted using the target_getProperty, with TP_BUFFER and 1 for index<br>

As you can see in the callback you have all the parameters of the targetting action.

\subsection targetaction Put it in action
After all this theoretical explanation what should you do to get this all working?
The typical target code should be:

\code
public a_function(const chr, ...)
{
	chr_message(chr, _, "Target something ...");
	target_create(chr, _, _, _, "callback");
}

public callback(target, chr, object, param1, x ,y ,z ,model, param1)
{
	//do something here
}
\endcode

This is all you need to manage a target, the first function will send the target to the character with a message
and the callback will be activated on target use.<br>
When you write code in the callback you have to take in consideration that the exact moment the function
will be called is not known.

\subsection advancedtarget Advanced target use
You surely have noticed that we didn't use all target_create parameters, neither we used the target_do function.
This features are for advanced target use.
The first 2 additional parameters param1 and param2 are simply used to pass something to the callback wothout having to
declare global variables/local vars, so that's not such an advanced used.
the doNow paramter is mre interesting: it allows you to create the target (so getting a serial for it) without sending it to the
player, simply use

\code
target_create(chr,_,_,false,"callback");
\endcode

and your target won't be sent.<br>
This feature allows you a complex target management, so you can create many targets with a function and then
activate them when needed with target_do(target, chr). This way you can use the same target for more than one character too.<br>
The additional parameters after the callback name are used to build the callback name at runtime.

\code
N = 10;
new targets[N];
for(new i = 0; i<N ; i++)
	targets[i] = target_create(chr, _,_,_,"callback%d",i)	
\endcode

will create N targets that will have callbacks named callback0, callback1, callback2 ... and so on.

\subsection oldtarget Switching from old target system
All these interesting target features are available only from the newest 0.82 versions, those of you 
who are yousing the old system (with getTarget) will find that old system is no longer supported.
You can easily switch to new system replacing your old

\code
getTarget(chr, funcidx("callback"), "message");
\endcode

with the new

\code
chr_message(chr,_,"message");
target_create(chr,_,_,_,"callback");
\endcode
*/
